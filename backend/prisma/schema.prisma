generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [citext]
}

/**
 * =========================
 * Roles / Permisos / Usuario
 * =========================
 */
model Rol {
  id            Int             @id @default(autoincrement())
  nombre        String          @unique @db.Citext
  activo        Boolean         @default(true)
  actualizadoEn DateTime        @default(now()) @updatedAt
  creadoEn      DateTime        @default(now())
  sistema       Boolean         @default(false)
  permisos      PermisoPorRol[]
  usuarios      Usuario[]
}

model Permiso {
  id          Int             @id @default(autoincrement())
  nombre      String          @unique @db.Citext
  descripcion String?
  roles       PermisoPorRol[]
}

model PermisoPorRol {
  id        Int     @id @default(autoincrement())
  permisoId Int
  rolId     Int
  permiso   Permiso @relation(fields: [permisoId], references: [id])
  rol       Rol     @relation(fields: [rolId], references: [id])

  @@unique([permisoId, rolId])
}

model Usuario {
  id                  Int      @id @default(autoincrement())
  nombre              String
  usuario             String   @unique @db.Citext
  correo              String   @unique @db.Citext
  contrasena          String?
  estado              Boolean  @default(true)
  creadoEn            DateTime @default(now())
  actualizadoEn       DateTime @updatedAt
  debeCambiarPassword Boolean  @default(false)
  rolId               Int

  areasCreadas        Area[]
  bolsasCreadas       Bolsa[]
  lotesQRCreados      LoteQR[]
  tiposDesechoCreados TipoDesecho[]

  // Relaciones nombradas para evitar ambig√ºedad
  registrosCreados  Registro[] @relation("RegistroCreadoPor")
  registrosCerrados Registro[] @relation("RegistroCerradoPor")
  etiquetasUsadas   EtiquetaQR[] @relation("EtiquetaUsadaPor")

  rol Rol @relation(fields: [rolId], references: [id])

  /// Pol√≠tica de contrase√±as
  ultimoCambioContrasena  DateTime?             @db.Timestamptz
  contrasenaHistoriales   ContrasenaHistorial[]
  /// Cooldown de recuperaci√≥n
  ultimoEnvioRecuperacion DateTime?             @db.Timestamptz

  @@index([estado])
  @@index([ultimoCambioContrasena])
  @@index([debeCambiarPassword])
  @@index([ultimoEnvioRecuperacion])
}

/**
 * ================
 * Cat√°logos
 * ================
 */
model Area {
  id            Int      @id @default(autoincrement())
  nombre        String   @unique @db.Citext
  descripcion   String?
  estado        Boolean  @default(true)
  creadoPorId   Int
  creadoEn      DateTime @default(now())
  actualizadoEn DateTime @updatedAt

  creadoPor     Usuario         @relation(fields: [creadoPorId], references: [id])
  EtiquetaQR    EtiquetaQR[]
  LoteQR        LoteQR[]
  RegistroLinea RegistroLinea[]

  // M‚ÜîN configurado: tipos permitidos por √°rea
  tiposPermitidos AreaTipoDesecho[]

  @@index([estado])
}

model TipoDesecho {
  id            Int      @id @default(autoincrement())
  nombre        String   @unique @db.Citext
  /// Slug estable para reglas/reportes (COMUN, ESPECIALES, INFECCIOSOS, PATOLOGICOS, PUNZOCORTANTES‚Ä¶)
  slug          String   @unique @db.Citext
  descripcion   String?
  estado        Boolean  @default(true)
  creadoPorId   Int
  creadoEn      DateTime @default(now())
  actualizadoEn DateTime @updatedAt

  creadoPor     Usuario         @relation(fields: [creadoPorId], references: [id])
  bolsas        Bolsa[]
  RegistroLinea RegistroLinea[]

  // M‚ÜîN configurado: √°reas donde este tipo est√° permitido
  areasPermitidas AreaTipoDesecho[]

  @@index([estado])
}

/**
 * Tabla puente para configurar qu√© tipos est√°n permitidos en cada √°rea.
 * Permite filtrar el combo de Tipos tras elegir un √Årea.
 */
model AreaTipoDesecho {
  areaId        Int
  tipoDesechoId Int
  activo        Boolean @default(true)

  area Area        @relation(fields: [areaId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  tipo TipoDesecho @relation(fields: [tipoDesechoId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  @@id([areaId, tipoDesechoId])
  @@index([tipoDesechoId])
  @@index([areaId, activo])
  @@index([tipoDesechoId, activo])
}

model Bolsa {
  id          Int     @id @default(autoincrement())
  color       String  @db.Citext
  tamano      String
  descripcion String?
  estado      Boolean @default(true)

  // Cada bolsa pertenece a un tipo de desecho
  tipoDesechoId Int
  tipoDesecho   TipoDesecho @relation(fields: [tipoDesechoId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  creadoPorId   Int
  creadoEn      DateTime @default(now())
  actualizadoEn DateTime @updatedAt

  creadoPor     Usuario         @relation(fields: [creadoPorId], references: [id])
  EtiquetaQR    EtiquetaQR[]
  LoteQR        LoteQR[]
  RegistroLinea RegistroLinea[]

  // Permite repetir color/tama√±o entre tipos distintos
  @@unique([tipoDesechoId, color, tamano])
  @@index([estado])
  @@index([tipoDesechoId])
}

/**
 * =========================
 * Lotes y Etiquetas QR
 * =========================
 */
model LoteQR {
  id            Int      @id @default(autoincrement())
  areaId        Int
  bolsaId       Int
  cantidad      Int
  porHoja       Int      @default(4)
  creadoPorId   Int?
  creadoEn      DateTime @default(now())
  actualizadoEn DateTime @updatedAt

  etiquetas EtiquetaQR[]
  area      Area         @relation(fields: [areaId], references: [id])
  bolsa     Bolsa        @relation(fields: [bolsaId], references: [id])
  creadoPor Usuario?     @relation(fields: [creadoPorId], references: [id])

  @@index([areaId])
  @@index([bolsaId])
}

model EtiquetaQR {
  id            Int       @id @default(autoincrement())
  codigo        String    @unique @db.Citext
  loteId        Int
  areaId        Int
  bolsaId       Int
  estado        EstadoQR  @default(ACTIVA)
  creadoEn      DateTime  @default(now())
  actualizadoEn DateTime  @updatedAt
  usadoEn       DateTime?

  // qui√©n la us√≥ (opcional)
  usadoPorId Int?
  usadoPor   Usuario? @relation("EtiquetaUsadaPor", fields: [usadoPorId], references: [id])

  area          Area            @relation(fields: [areaId], references: [id])
  bolsa         Bolsa           @relation(fields: [bolsaId], references: [id])
  lote          LoteQR          @relation(fields: [loteId], references: [id])
  RegistroLinea RegistroLinea[]

  @@index([loteId])
  @@index([estado])
  @@index([areaId, bolsaId])
  @@index([loteId, estado])
  @@index([usadoPorId])
}

enum EstadoQR {
  ACTIVA
  USADA
  ANULADA
}

/**
 * =========================
 * Registros gen√©ricos (compat con tu tabla actual)
 * =========================
 * Mapeamos el modelo `Registro` a la tabla f√≠sica existente `RegistroDiario`
 * y el enum `EstadoRegistro` al enum f√≠sico `RegistroEstado`.
 * - ABIERTO (nuevo) ‚Üî BORRADOR (viejo)
 * - CERRADO (nuevo) ‚Üî CERRADO (viejo)
 */
enum EstadoRegistro {
  ABIERTO @map("BORRADOR")
  CERRADO @map("CERRADO")

  @@map("RegistroEstado")
}

model Registro {
  id Int @id @default(autoincrement())

  /// Identificaci√≥n libre
  titulo String?
  nota   String?

  /// Trazabilidad temporal (reutilizamos columnas viejas)
  abiertoAt     DateTime  @default(now()) @map("creadoEn") // usa columna creadaEn
  actualizadoEn DateTime  @updatedAt // mapea a actualizadoEn (mismo nombre)
  cerradoAt     DateTime? @map("cerradoEn")

  /// Estado mapeado al enum f√≠sico existente
  estado EstadoRegistro @default(ABIERTO) @map("estado")

  /// Modo de entrada informativo
  modoEntrada String? @map("modoEntrada")

  /// Usuario que lo abri√≥ (reutiliza `responsableId`) ‚Äî relaci√≥n nombrada
  creadoPorId Int     @map("responsableId")
  creadoPor   Usuario @relation("RegistroCreadoPor", fields: [creadoPorId], references: [id])

  /// Usuario que cerr√≥ (nuevo) ‚Äî relaci√≥n nombrada
  cerradoPorId Int?
  cerradoPor   Usuario? @relation("RegistroCerradoPor", fields: [cerradoPorId], references: [id])

  /// Campo LEGACY para conservar la columna f√≠sica `fecha` sin borrarla
  fechaLegacy DateTime @default(now()) @map("fecha")

  /// Acumulado de peso (nuevo)
  totalPesoLb Decimal @default(0) @db.Decimal(12, 3)
  /// PDF generado al cerrar (nuevo)
  pdfUrl      String?

  /// L√≠neas capturadas
  lineas RegistroLinea[]

  @@index([estado])
  @@index([abiertoAt])
  @@index([creadoPorId])
  @@index([cerradoPorId])
  @@map("RegistroDiario") // ‚Üê usa tu tabla actual
}

model RegistroLinea {
  id Int @id @default(autoincrement())

  /// Relaci√≥n con el registro (FK f√≠sica a RegistroDiario.id)
  registroId Int
  registro   Registro @relation(fields: [registroId], references: [id], onDelete: Cascade)

  /// Si se escanea una etiqueta QR, se guarda; si es manual, puede ser NULL y se guarda `codigo`.
  etiquetaId Int?
  etiqueta   EtiquetaQR? @relation(fields: [etiquetaId], references: [id])

  /// C√≥digo manual cuando no hay etiqueta (opcional, informativo)
  codigo String?

  /// Hora puntual de la l√≠nea
  hora DateTime @default(now())

  areaId Int
  area   Area @relation(fields: [areaId], references: [id])

  bolsaId Int
  bolsa   Bolsa @relation(fields: [bolsaId], references: [id])

  /// Se guarda expl√≠citamente el tipo de desecho
  tipoDesechoId Int
  tipoDesecho   TipoDesecho @relation(fields: [tipoDesechoId], references: [id])

  /// Libras con 3 decimales
  pesoLb Decimal @db.Decimal(10, 3)

  creadoEn DateTime @default(now())

  /// üîê Anti-duplicados
  /// 1) Compat: evita repetir la misma etiqueta dentro del mismo registro
  @@unique([registroId, etiquetaId])
  /// 2) **Regla global**: una etiqueta s√≥lo puede usarse una vez en toda la historia
  @@unique([etiquetaId], name: "uniq_linea_por_etiqueta")

  @@index([registroId])
  @@index([etiquetaId])
  @@index([areaId])
  @@index([bolsaId])
  @@index([tipoDesechoId])
  @@index([hora])
}

/**
 * =========================
 * Seguridad: Historial de contrase√±as
 * =========================
 */
model ContrasenaHistorial {
  id        Int      @id @default(autoincrement())
  usuario   Usuario  @relation(fields: [usuarioId], references: [id], onDelete: Cascade)
  usuarioId Int
  hash      String
  creadoEn  DateTime @default(now())

  @@index([usuarioId, creadoEn])
}
